Chapter3 람다 표현식

3.1 람다란?

익명 클래스로 다양한 동작을 구현 할 수 있지만 코드가 만족할 만큼 깔끔하지 못하다.
더 깔끔한 코드로 동장을 구현하기 위해 자바8부터 람다 표현식을 제공해준다.

람다 표현식 : 메서드를 전달 할 수 있는 익명 함수를 단순화한 것

람다의 특징
	익명
-	보통의 메서드와 다르게 이름이 없는 메서드
-	구현해야하는 코드에 대한 걱정거리가 줄어듦

	함수
-	특정 클래스에 종속되지 않아 함수라고 부름
-	파라미터 리스트, 바디, 반환 형식, 가능한 예외 리스트 포함

	전달
-	메서드 인수를 전달하거나 변수를 저장

	간결성
-	익명 클래스처럼 많은 코드를 구현할 필요가 없다.

람다 표현식
람다 표현식은 파라미터와 바디로 이루어져 있다.

(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

표현식 스타일 람다
()  ->  “Study”

블록스타일 ( 명시적으로 return 문을 사용 )
()  ->  {return “Study”;}


3.2 어디에, 어떻게 람다를 사용할까?

* 함수형 인터페이스를 인수로 받는 메서드만 람다 표현식을 사용할 수 있다.
  언어 설계자들이 언어를 더 복잡하게 만들지 않는 현재 방법을 선택
  대부분 자바 프로그래머가 하나의 추상 메서드를 갖는 인터페이스에 익숙

- 함수형 인터페이스(하나의 추상 메서드를 지정하는 인터페이)에서 사용
- 디스크립터 (람다 표현식의 시그니처를 서술하는 메서드)
- @FunctionalInterface : 자바 API에 함수형 인터페이스임을 가리키는 어노테이션이 추가


3.3 람다 활용: 실행 어라운드 패턴

실행 어라운드 패턴 : 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태 갖는 형식

3.4 함수형 인터페이스 사용

다양한 람다 표현식을 사용하려면 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요

자바8 라이브러리 java.util.function 패키지에서 새로운 함수형 인터페이스를 제공

- Predicate
T 형식의 객체를 사용하는 불리언 표현식이 필요한 상황에서 사용

- Consumer
제네릭 형식 T 객체를 받아서 void를 반환을 하기 위해 사용

- Function
제네릭 형식 T를 인수로 받아 R 형식 객체를 반환하기 위해 사용

* 기본형 특화
자바의 형식은 참조형(Byte, Integer, Object, List)과 기본형(int, double, byte, char)으로 되어 있다.
제네릭 파라미터에는 참조형만 사용할 수 있다.

    박싱 : 기본형 => 참조형
    언박싱 : 참조형 => 기본형
    오토박싱 : 박싱과 언박싱을 자동으로 해주는것

* 예외, 람다, 함수형 인터페이스 관계
    1. 예외를 선언하는 함수형 인터페이스를 직접 정의
    2. 람다를 try/ catch 블록으로 감싸야한다.


3.5 형식 검사, 형식 추론, 제약

1.  형식 검사

람다가 사용되는 콘텍스트를 이용해서 람다의 형식을 추론할 수 있다.
- 콘텍스트 : 람다가 전달될 메서드 파라미터나 람다가 할당되는 변수

콘텍스트에서 기대되는 람다 표현식의 형식을 대상 형식이라고 부른다.

* 람다 표현식이 예외를 던질 수 있다면 추상 메서드도 같은 예외를 던질 수 있도록 throws로 선언

대상형식 : 람다가 전달될 파라미터나 람다가 할당되는 변수 등에서 기대되는 람다 표현식의 형식을 대상 형식이라 부른다.
ex) Predicate<T>
    Predicate<T> 라는 대상 형식에 만족하는 람다 함수를 기대하는 것이다.

대상 형식이라는 특징 때문에 같은 람다 표현식이라도 호횐되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용할 수 있다.
Callable<Integer> c = () -> 42;
PrivilegedAction<Ingeger> p = () -> 42;

하나의 람다 표현식을 다양한 함수형 인터페이스에 사용할 수 있다.

* 다이아몬드 연산자
List<Integer> list = new ArrayList<>()
=> 중복된 타입 파라미터를 생략한 다이아몬드(<>) 연산자

* 특별한 void 호환 규칙
람다 바디에 일반 표현식이 있다면 void 값을 return하는 Consumer 대신 boolean값을 return하는 함수를 사용가능


2. 형식 추론

자바 컴파일러는 람다 표현식이 사용된 콘텍스트(대상 형식)를 이용하여 람다 표현식과 관련된 함수형 인터페이스를 추론
=> 컴파일러는 람다의 시그니쳐 추론을 통해 람다 표현식의 파라미터 형식에 접근 할 수 있으므로 파라미터 형식이 생략 가능


3. 지역변수 사용

람다 표현식에서 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수(자유변수)를 활용이 가능
=> 람다 캡처링

ex) int portNumber = 1337;
    Runnable r = () -> System.out.println(portNumber);

* 지역 변수 제약
지역 변수를 사용하기 위해서는 지역변수가 final로 선언되어 있어야 하거나 실질적으로 final로 선언된 변수와 똑같이 사용되어야한다.

=> 람다가 지역변수를 바로 접근하게 될 경우 람다가 쓰레드에서 실행 될때 지역 변수의 수명이 다해 할당이 해제되는 경우가 발생할 수 있다.
   이러한 문제를 막기 위해 복사본을 이용하고 복사본을 사용하기 위해서는 값이 바뀌지 않아야 한다는 제약 사항이 발생하게 된것

3.6 메서드 참조

메서드 명 앞에 구분자(::)을 붙이는 방식으로 메소드 참조를 사용
메서드 참조를 사용하면 가독성을 높일 수 있다.

(Apple apple) -> apple.getWeight()       =====>    Apple::getWeight

- 메서드 참조를 만드는 방법
  1. 정적 메서드 참조
  Integer 메서드에 parseInt 메서드를 Integer::parseInt 로 표현

  2. 다양한 형식의 인스턴스 메서드 참조
  String의 length 메서드를 String::length로 표현
  ex) (String s) -> s.ToUpperCase()
      String::ToUpperCase

  3. 기존 객체의 인스턴스 메서드 참조
  Transaction 객체를 할당받은 expensiveTransaction 지역변수, Transaction 객체에 getValue메서드가 있다면
  expensiveTransaction::getValue 로 표현
  ex) () -> expensiveTransaction.getValue()
      expensiveTransaction::getValue


3.7 람다, 메서드 참조 활용하기

